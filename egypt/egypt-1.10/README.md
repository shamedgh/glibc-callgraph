# Glibc CFG Generation

## Initial CFG
The initial CFG is generated by passing the RTL (glibc IR) files for all the 
glibc object files.
To create the RTL files we need to pass the following c flag the compiler:
```
make CFLAGS=-fdump-rtl-expand
```
Then we gather the full path to all RTL files using a simple find command:
```
find PATH_TO_BUILD/ -name "*.expand" > tmp
```
We finally run egypt on all the files: (There is a comment that we added to the egypt script which increases the edges in line 261)
```
./egypt -include-external `cat tmp` > initial.part1.cfg
```
Egypt limits and removes some of the edges by default which it identifies as references.
We remove this limitation and re-run egypt to add any missing edges due to this issue.
```
./egypt.modified -include-external `cat tmp` > initial.part2.cfg
```

We concat the two files to generate our initial callgraph:
```
cat initial.part1.cfg > initial.cfg
cat initial.part2.cfg >> initial.cfg
```


Then we have to clean the initial graph using the following command:
```
python2.7 parse_callgraph_wrapper.py initial.cfg > initial.cleaned.cfg
```

## Function to Syscall
The initial CFG can't extract calls to the system calls themselves, because 
many of the system call invocation code is created by macros and exist in 
the assembly files.
We extract those by parsing the make log (holds macros converted to syscall 
code) and the RTLs manually for calls to the system calls.
We use the following script for extracting the system calls which exist in 
the C code:
```
python parse_rtl_for_syscall.py sample.expand >> funcToSyscall.cfg
```
We use the next script for parsing the make log:
```
python parse_make_log.py path_to_log >> funcToSyscall.cfg
```

## Weak Aliases
We need to run a grep on the source code to extract weak aliase:
```
find . -name "*.c" -o -name "*.h" | xargs grep "weak_alias" | awk '{print $2 $3}' 
```

## Strong Aliases
We need to run a grep on the source code to extract strong aliase:
```
find . -name "*.c" -o -name "*.h" | xargs grep "strong_alias" | awk '{print $2 $3}'
```

## Versioned Symbols

```
find . -name "*.c" -o -name "*.h" | xargs awk '/versioned_symbol \(/,/;/'
```

## Combat Symbols

```
find . -name "*.c" -o -name "*.h" | xargs awk '/compat_symbol \(/,/;/'
```

Now we can run the main script which is wrapper.py:
```
python2.7 wrapper.py glibc.2.33/initial.all.cfg glibc.2.33/all.expand.files ~/library-debloating/libsrccodes/glibc/build/build.log glibc.2.33/weakalias glibc.2.33/versioned_symbols glibc.2.33/compat_symbols glibc.2.33/strongalias >> glibc.2.33/wrapper.out.new
```

This gives us anything missing from the initial graph, and by adding the initial graph to it, we generate the complete graph.
