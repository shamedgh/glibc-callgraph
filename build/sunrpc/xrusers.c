/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rpcsvc/rusers.h"
/*
 * Find out about remote users
 */

bool_t
xdr_rusers_utmp (XDR *xdrs, rusers_utmp *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->ut_user, RUSERS_MAXUSERLEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->ut_line, RUSERS_MAXLINELEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->ut_host, RUSERS_MAXHOSTLEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ut_type))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ut_time))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->ut_idle))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_utmp_array (XDR *xdrs, utmp_array *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->utmp_array_val, (u_int *) &objp->utmp_array_len, ~0,
		sizeof (rusers_utmp), (xdrproc_t) xdr_rusers_utmp))
		 return FALSE;
	return TRUE;
}
bool_t xdr_utmp (XDR *xdrs, struct ru_utmp *objp);

bool_t
xdr_utmp (XDR *xdrs, struct ru_utmp *objp)
{
 /* Since the fields are char foo [xxx], we should not free them. */
 if (xdrs->x_op != XDR_FREE)
 {
 char *ptr;
 unsigned int size;
 ptr = objp->ut_line;
 size = sizeof (objp->ut_line);
 if (!xdr_bytes (xdrs, &ptr, &size, size)) {
 return (FALSE);
 }
 ptr = objp->ut_name;
 size = sizeof (objp->ut_name);
 if (!xdr_bytes (xdrs, &ptr, &size, size)) {
 return (FALSE);
 }
 ptr = objp->ut_host;
 size = sizeof (objp->ut_host);
 if (!xdr_bytes (xdrs, &ptr, &size, size)) {
 return (FALSE);
 }
 }
 if (!xdr_long(xdrs, &objp->ut_time)) {
 return (FALSE);
 }
 return (TRUE);
}

bool_t xdr_utmpptr(XDR *xdrs, struct ru_utmp **objpp);

bool_t
xdr_utmpptr (XDR *xdrs, struct ru_utmp **objpp)
{
 if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct ru_utmp),
 (xdrproc_t) xdr_utmp)) {
 return (FALSE);
 }
 return (TRUE);
}

bool_t
xdr_utmparr (XDR *xdrs, struct utmparr *objp)
{
 if (!xdr_array(xdrs, (char **)&objp->uta_arr, (u_int *)&objp->uta_cnt,
 MAXUSERS, sizeof(struct ru_utmp *),
 (xdrproc_t) xdr_utmpptr)) {
 return (FALSE);
 }
 return (TRUE);
}

bool_t xdr_utmpidle(XDR *xdrs, struct utmpidle *objp);

bool_t
xdr_utmpidle (XDR *xdrs, struct utmpidle *objp)
{
 if (!xdr_utmp(xdrs, &objp->ui_utmp)) {
 return (FALSE);
 }
 if (!xdr_u_int(xdrs, &objp->ui_idle)) {
 return (FALSE);
 }
 return (TRUE);
}

bool_t xdr_utmpidleptr(XDR *xdrs, struct utmpidle **objp);

bool_t
xdr_utmpidleptr (XDR *xdrs, struct utmpidle **objpp)
{
 if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct utmpidle),
 (xdrproc_t) xdr_utmpidle)) {
 return (FALSE);
 }
 return (TRUE);
}

bool_t
xdr_utmpidlearr (XDR *xdrs, struct utmpidlearr *objp)
{
 if (!xdr_array(xdrs, (char **)&objp->uia_arr, (u_int *)&objp->uia_cnt,
 MAXUSERS, sizeof(struct utmpidle *),
 (xdrproc_t) xdr_utmpidleptr)) {
 return (FALSE);
 }
 return (TRUE);
}
